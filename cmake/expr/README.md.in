# CMake Expression Syntax

_This Document is currently just a draft_

@markdown_section(expr_motivation "Motivation")


CMake's syntax is not sexy. It does not allow the developer rudimentary constructs which almost all other languages have.  But because CMake's language is astonishingly flexible I was able to create a lexer and parser and interpreter for a custom 100 % compatible syntax which (once "JIT compiled") is also fast.


@markdown_section(expr_example "Example")

The easiest way to introduce the new syntax and its usefulness is by example. So here it is (Note that these example are actually executed during the generation of this document using my cmake template engine ([link](#)) so the result displayed is actually computed).

```cmake
# values
## number
<%>>markdown_eval expr(1)%> 

## bool
<%>>markdown_eval expr(true)%>
<%>>markdown_eval expr(false)%>

## null
<%>>markdown_eval expr(null)%>

## single quoted string
<%>>markdown_eval expr("'hello world'")%> 
<%>>markdown_eval expr("'null'")%> 

## double quoted string
<%>>markdown_eval expr("\"hello world\"")%>

## separated string (a string which is a single argument)
<%>>markdown_eval expr("hello world")%> 

## unquoted
<%>>markdown_eval expr(hello) %>

## list
<%>>markdown_eval expr([1,2,3]) %>

## object 
<%>>markdown_eval expr({first_name:Tobias, 'last_name': "Becker" }) %>

## complex value
<%>>markdown_eval expr({value:[1,{a:2,b:{c:[3,4,5],d:2}},{}]}) %>

## concatenation 
<%>>markdown_eval expr(hello world 1 null 2 'null' 3)%>


# scope variables
## variable
<%>>markdown_eval set(my_var "hello world")
expr($my_var)%>

## variable scope variable 
<%>>markdown_eval set(my_var "hello world")
set(var_name my_var)
expr($($var_name)) %>

## assign scope variable
<%>>markdown_eval expr($a = 1)
assert("${a}" EQUAL 1) %>

# function
<%>>markdown_eval ## test function
function(my_add lhs rhs)
    math(EXPR sum "${lhs} + ${rhs}")
    return("${sum}")
endfunction()
## call normal cmake function
expr(my_add(1,2)) %>

## use function invocation as argument (`f(g(x))`)
<%>>markdown_eval expr(my_add(my_add(my_add(1,2),3),4))%>
 
## use bind call which inserts the left hand value into a function as the first parameter 
<%>>markdown_eval expr("hello there this is my new title"::string_to_title())%>

## combine all the things!

 expr(
    $func = 

    )

## more examples...

```

@markdown_section(expr_functions "Functions and Datatypes")

I provide the following functions for you to interact with `expr`.  
<% set(function_files 
    expr.cmake 
    expr_eval.cmake 
    expr_parse.cmake
    cmakepp_compile.cmake
    cmakepp_compile_file.cmake
    cmakepp_eval.cmake
    cmakepp_include.cmake
    ) %>

@markdown_template_function_list(${function_files})

@markdown_template_function_descriptions(${function_files})

@markdown_section(expr_definition "The Expression Language Definition")

I mixed several constructs and concepts from different languages which I like - the syntax should be familiar for someone who knows JavaScript and C++.  I am not a professional language designer so some decisions might seem strange however I have tested everything thouroughly.

The examples are not cmake strings. They need to be escaped again in some cases
```
## the forbidden chars are used by the tokenizer and using them will cause the world to explode. They are all valid ASCII codes < 32 and > 0 
<forbidden char> ::=  SOH | NAK | US | STX | ETX | GS | FS | SO  
<escapeable char> :: = "\" """ "'"  
<free char> ::= <ascii char>  /  <forbidden char> / <escapablechar> 
<escaped char> 
<quoted string content> ::= <<char>|"\" <escaped char>>* 

## strings 
<double quoted string> ::= """ <quoted string content> """
    expr("\"\"")    => ``
    expr("\"hello\"")   => `hello`
    expr("\"\\' single quote\"")    => `' single quote`
    expr"\"\\\" double quote\"" => `" double quote`
    expr("\\ backslash")    => `\ backslash`

<double quoted string> ::= "'" <quoted string content> "'"
    expr("''")    =>  ``
    expr('')    =>  ``
    expr("'hello'")   =>  `hello`
    expr('hello')   =>  `hello`
    expr("'\\' single quote'")    =>  `' single quote`
    expr("'\\\" double quote'")
    expr('\\ backslash')
    expr('\" double quote')

<unquoted string> ::= 
    ...
<separated string> ::= 
    ""
    "hello world"
    ...

<string> ::= <double quoted string> | <single quoted string> | <unquoted string> | <separated string>

## every literal is a const string 
## some unquoted strings have a special meaning
## quoted strings are always strings even if their content matches one
## of the specialized definitions
<number> ::= /0|[1-9][0-9]*/
    number
        0
        1
        912930
    NOT number:
        01
        "'1'" 
        "\"1\""

<bool> ::= "true" | "false"
    bool
        true
        false
    NOT bool
        "'true'"
        "\"false\""

<null> ::= "null"
    null
        null
    NOT null
        "'null'"

<literal> ::= <string>|<number>|<bool>|<null>
    valid literal
        "hello world"
        123
        "'123'"
        true
        null
        ""
        abc




<value> ::= <paren>|<value dereference>|<value reference>|<ellipsis>|<literal>|<interpolation>|<bind call>|<call>|<list>|<object>|<scope variable>|<indexation>|<navigation>

## an interpolation combines multiple values into a single value
<interpolation> ::= <value> * 
    expr("a" "b" "c") => `abc`

<expression> ::= <assign>|<value> 

```



## Performance

Here is some performance data for the cmake expression syntax


Expression | Token Count | Ast Nodes | Compile Time | Cached Compile Time |  Execution Time | Compile Statements
`$the_object.e[0,1]...['a']` | 15 | 9 | 420 ms | 5 ms | 22



## Still Open

* derefernce 
* address of
* out value
    - `$` as result indicator
    - 
* lvalue range
* lvalue range assign
* lvalue range assign ellipsis
* lambda
* statements
* closures
* force path existance
* operators
    - *math* CMake needs a basic math system to be inplace `math(EXPR)` is really, really bad. 
        + `+`
        + `-`
        + `*`
        + `/`
        + `%`
    - string 
    - any
        + `??` null coalescing operator
    





## Future Work

When the syntax is complete and this feature works well the next step is to incorporate it into CMake using C code.  This will make everything much, much faster and will get rid of those hideous generator expressions.  Maybe even the whole cmake script language itself.