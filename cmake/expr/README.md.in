# CMake Expression Syntax

_This Document is currently just a draft_

@markdown_section(expr_motivation "Motivation")


CMake's syntax is not sexy. It does not allow the developer rudimentary constructs which almost all other languages have.  But because CMake's language is astonishingly flexible I was able to create a lexer and parser and interpreter for a custom 100 % compatible syntax which (once "JIT compiled") is also fast.


@markdown_section(expr_example "Example")

The easiest way to introduce the new syntax and its usefulness is by example. So here it is (Note that these example are actually executed during the generation of this document using my cmake template engine ([link](#)) so the result displayed is actually computed).

```cmake
# values
## number
<%>>markdown_eval expr(1)%> 

## bool
<%>>markdown_eval expr(true)%>
<%>>markdown_eval expr(false)%>

## null
<%>>markdown_eval expr(null)%>

## single quoted string
<%>>markdown_eval expr("'hello world'")%> 
<%>>markdown_eval expr("'null'")%> 

## double quoted string
<%>>markdown_eval expr("\"hello world\"")%>

## separated string (a string which is a single argument)
<%>>markdown_eval expr("hello world")%> 

## unquoted
<%>>markdown_eval expr(hello) %>

## list
<%>>markdown_eval expr([1,2,3]) %>

## object 
<%>>markdown_eval expr({first_name:Tobias, 'last_name': "Becker" }) %>

## complex value
<%>>markdown_eval expr({value:[1,{a:2,b:{c:[3,4,5],d:2}},{}]}) %>

## concatenation 
<%>>markdown_eval expr(hello world 1 null 2 'null' 3)%>


# scope variables
## variable
<%>>markdown_eval set(my_var "hello world")
expr($my_var)%>

## variable scope variable 
<%>>markdown_eval set(my_var "hello world")
set(var_name my_var)
expr($($var_name)) %>

## assign scope variable
<%>>markdown_eval expr($a = 1)
assert("${a}" EQUAL 1) %>

# function
<%>>markdown_eval ## test function
function(my_add lhs rhs)
    math(EXPR sum "${lhs} + ${rhs}")
    return("${sum}")
endfunction()
## call normal cmake function
expr(my_add(1,2)) %>

## use function invocation as argument (`f(g(x))`)
<%>>markdown_eval expr(my_add(my_add(my_add(1,2),3),4))%>
 
## use bind call which inserts the left hand value into a function as the first parameter 
<%>>markdown_eval expr("hello there this is my new title"::string_to_title())%>

## enabling cmakepp expressions for the current function scope
<%>>markdown_eval function(my_test_function) 
    ## here expressions ARE NOT evaluated yet
    set(result "unevaluated $[hello world]")
    ## this call causes cmakepp expressions to be evaluated for
    ## the rest of the current function body
    cmakepp_enable_expressions(${CMAKE_CURRENT_LIST_LINE})
    ## here expressions ARE being evaluated
    set(result "${result} evaluated: $[hello world]")
    return(${result})
endfunction()
my_test_function()%>

## more examples...

```

@markdown_section(expr_functions "Functions and Datatypes")

I provide the following functions for you to interact with `expr`.  
<% set(function_files 
    expr.cmake 
    expr_eval.cmake 
    expr_parse.cmake
    cmakepp_expr_compile.cmake
    cmakepp_compile_file.cmake
    cmakepp_eval.cmake
    cmakepp_include.cmake
    cmakepp_enable_expressions.cmake
    ) %>

@markdown_template_function_list(${function_files})

@markdown_template_function_descriptions(${function_files})

@markdown_section(expr_definition "The Expression Language Definition")

I mixed several constructs and concepts from different languages which I like - the syntax should be familiar for someone who knows JavaScript and C++.  I am not a professional language designer so some decisions might seem strange however I have tested everything thouroughly.

The examples are not cmake strings. They need to be escaped again in some cases
```
## the forbidden chars are used by the tokenizer and using them will cause the world to explode. They are all valid ASCII codes < 32 and > 0 
<forbidden char> ::=  SOH | NAK | US | STX | ETX | GS | FS | SO  
<escapeable char> :: = "\" """ "'"  
<free char> ::= <ascii char>  /  <forbidden char> / <escapablechar> 
<escaped char> 
<quoted string content> ::= <<char>|"\" <escaped char>>* 

## strings 
<double quoted string> ::= """ <quoted string content> """
    <%>>markdown_eval expr("\"\"")%>
    <%>>markdown_eval expr("\"hello\"")%>
    <%>>markdown_eval expr("\"\\' single quote\"")%>
    <%>>markdown_eval expr("\"\\\" double quote\"")%>
    <%>>markdown_eval expr("\"\\ backslash\"")%>

<single quoted string> ::= "'" <quoted string content> "'"
    <%>>markdown_eval expr("''")%>
    <%>>markdown_eval expr('')%>
    <%>>markdown_eval expr("'hello'")%>
    <%>>markdown_eval expr('hello')%>
    <%>>markdown_eval expr("'hello world'")%>
    <%>>markdown_eval expr("'\\' single quote'")%>
    <%>>markdown_eval expr("'\\\" double quote'")%>
    <%>>markdown_eval expr("'\\\\ backslash'")%>

<unquoted string> ::= 
    <%>>markdown_eval expr(hello)%>

<separated string> ::= 
    <%>>markdown_eval expr("")%>
    <%>>markdown_eval expr("hello world")%>
    

<string> ::= <double quoted string> | <single quoted string> | <unquoted string> | <separated string>

## every literal is a const string 
## some unquoted strings have a special meaning
## quoted strings are always strings even if their content matches one
## of the specialized definitions
<number> ::= /0|[1-9][0-9]*/
    number
        <%>>markdown_eval expr(0)%>
        <%>>markdown_eval expr(1)%>
        <%>>markdown_eval expr(912930)%>
    NOT number:
        <%>>markdown_eval expr(01)%>
        <%>>markdown_eval expr('1')%>
        <%>>markdown_eval expr("\"1\"")%>

<bool> ::= "true" | "false"
    bool
        <%>>markdown_eval expr(true)%>
        <%>>markdown_eval expr(false)%>
    NOT bool
        <%>>markdown_eval expr('true')%>
        <%>>markdown_eval expr(\"false\")%>

<null> ::= "null"
    null
        <%>>markdown_eval expr(null)%>
    NOT null
        <%>>markdown_eval expr('null')%>

<literal> ::= <string>|<number>|<bool>|<null>
    valid literal
        <%>>markdown_eval expr("hello world")%>
        <%>>markdown_eval expr(123)%>
        <%>>markdown_eval expr('123')%>
        <%>>markdown_eval expr(true)%>
        <%>>markdown_eval expr(null)%>
        <%>>markdown_eval expr("")%>
        <%>>markdown_eval expr(abc)%>

<list> ::= "[" <empty> | (<value> ",")* <value> "]"
    <%>>markdown_eval expr("[1,2,3,4]")%>
    <%>>markdown_eval expr("[1]")%>
    <%>>markdown_eval expr("[string_to_title('hello world'), 'goodbye world'::string_to_title()]")%>

<key value> ::= <value>:<value>
<object property> ::= <key value> | <value>
<object> ::= "{" <empty> | (<object property> ",")* <object property> "}"
    <%>>markdown_eval expr({})%> 
    <%>>markdown_eval expr({a:b})%> 
    <%>>markdown_eval expr({a: ("hello world"::string_to_title())})%> 

<paren> ::= "(" <value> ")"
## ellipsis are treated differently in many situation
## if used in a function parameter the arguments will be spread out
## if used in a navigation or indexation expression the navigation or
## indexation applied to every element in value
<ellipsis> ::= <value> "..." 

## if lvalue is <null> it is set to the default value (the default default value is a address/map)
<default value> ::= <lvalue> "!" | "!" <value>  # specifying the default value

<value> ::= <paren> |
            | <value dereference>
            | <value reference>
            | <ellipsis>
            | <literal>
            | <interpolation>
            | <bind call>
            | <call>
            | <list>
            | <object>
            | <scope variable>
            | <indexation>
            | <navigation>
            | <paren>
            | <default value>

## a parameter can be a value or the returnvalue operator "$"
## if the return value operator is specified the output of that parameter
## is treated as the result of the function call 
## this is usefull for using function which do not adhere to the
## return value convention. If used multiple times inside a call
## the results are accumulated.   
<parameter> ::= <value> | "$" 

<parameters> ::= "(" <empty> | (<parameter> "," )* <parameter>  ")"

<normal call> ::= <value> <parameters>
    <%>>markdown_eval expr(string_to_title("hello world"))%> 
    <%>>markdown_eval expr("eval_math('3 + 4')")%>

## bind call binds the left hand value as the first parameter of the function
<bind call> ::=  <value> "::" <value> <parameter>  
    <%>>markdown_eval expr("hello world"::string_to_title())%> 

<call> ::= <normal call> | <bind call>

<scope variable> ::= "$" <literal> 
    <%>>markdown_eval set(my_var hello!) 
    expr($my_var)%> 


<index> ::= "-"? <number> | "$" | "n"
<increment> ::= "-"? <number>
<range> ::= <empty> | <index> | <index> ":" <index> | <index> ":" <index> : <increment>

<indexation parameter> ::= <range> | <value>
<indexation parameters> ::= (<indexation parameter> ",")* <indexation parameter>
<indexation> ::= <value>"[" <indexation parameters> "]"
    <%>>markdown_eval expr("{a:1,b:2}['a','b']")%> 
    <%>>markdown_eval expr("[{a:1,b:2},{a:3,b:4}]...['a','b']")%>

<lvalue> ::= <scope variable> | <navigation> | <indexation>


<assign> ::= <lvalue> "=" <value>
    ## sets the scope variable my_value to 1
    <%>>markdown_eval expr($my_value = 1)
    expr($my_value)%> 
    ## coerces the scope value my_other_value to be an object
    <%>>markdown_eval #expr($my_other_value!.a!.b = 123)
    #expr($my_other_value)%> 


<expression> ::= <assign> | <value> 

```



## Performance

Here is some performance data for the cmake expression syntax


Expression | Token Count | Ast Nodes | Compile Time | Cached Compile Time |  Execution Time | Compile Statements
`$the_object.e[0,1]...['a']` | 15 | 9 | 420 ms | 5 ms | 22



## Still Open

* derefernce 
* address of
* out value
    - `$` as result indicator
    - 
* lvalue range
* lvalue range assign
* lvalue range assign ellipsis
* lambda
* statements
* closures
* force path existance
* operators
    - *math* CMake needs a basic math system to be inplace `math(EXPR)` is really, really bad. 
        + `+`
        + `-`
        + `*`
        + `/`
        + `%`
    - string 
    - any
        + `??` null coalescing operator
    





## Future Work

When the syntax is complete and this feature works well the next step is to incorporate it into CMake using C code.  This will make everything much, much faster and will get rid of those hideous generator expressions.  Maybe even the whole cmake script language itself.