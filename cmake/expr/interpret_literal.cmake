##
##
##
function(interpret_literal token)
 # json_print(${token})
  list(LENGTH token length)
  if(NOT "${length}" EQUAL 1)
    throw("only one token is acceptable, got ${length}" --function interpret_literal)  
  endif()
  map_tryget("${token}" type)
  ans(type)
  if(NOT "${type}" MATCHES "^((unquoted)|(quoted)|(number)|(separated))$")
    throw("invalid type for `literal`: `${type}`" --function interpret_literal)  
  endif()

  map_tryget("${token}" value)
  ans(result_value)
  if("${type}" MATCHES "^((unquoted)|(separated))$")
    if("${type}" STREQUAL "separated")
      string(REGEX MATCH ".(.*)." match "${result_value}")
      set(result_value "${CMAKE_MATCH_1}")
    endif()
    if("${result_value}" MATCHES "^(true)|(false)$")
      set(result_type bool)
    elseif("${result_value}" STREQUAL "null")
      set(result_type null)
      set(result_value)
    else()
      set(result_type unquoted_string)
    endif()
  elseif("${result_value}" MATCHES "^([\"'])(.*)[\"']$")
    if("${CMAKE_MATCH_1}" STREQUAL "'")
      set(result_type single_quoted_string)
    else()
      set(result_type double_quoted_string)
    endif()
    string(REGEX REPLACE "(\\\\)([\"'])" "\\2" result_value "${CMAKE_MATCH_2}")  
  elseif("${type}" STREQUAL "number")
    set(result_type number)
  endif()

  decode("${result_value}")
  ans(decoded_value)

  cmake_string_escape("${decoded_value}")
  ans(cmake_escaped)
 # message("escaped '${cmake_escaped}'")
  map_new()
  ans(ast)
  map_set("${ast}" static true)
  map_set("${ast}" type "${result_type}")
  map_set("${ast}" expression literal)
  map_set("${ast}" code "")
  map_set("${ast}" argument "${cmake_escaped}")
  map_set("${ast}" token "${token}") 
 # print_vars(result_type decoded_value token.value --plain)
#  json_print(${ast})
  return(${ast})
endfunction()